#pragma once
#include <typeindex>
#include <natRefObj.h>
#include <natException.h>
#include <natDelegate.h>
#include <natLinq.h>

using namespace NatsuLib;

DeclareException(ReflectionException, natException, _T("Exception generated by reflection."));
DeclareException(NullPointerException, ReflectionException, _T("Try to apply an operation which require pointer not null to a null pointer."));
DeclareException(InvalidArgumentException, ReflectionException, _T("One or more arguments are invalid."));

enum class AccessSpecifier
{
	AccessSpecifier_public,
	AccessSpecifier_protected,
	AccessSpecifier_private,
};

class ArgumentPack;

struct Interface
	: natRefObj
{
};

struct Object;
struct IType;

struct IMethod
	: Interface
{
	virtual AccessSpecifier GetAccessSpecifier() const noexcept = 0;
	virtual AccessSpecifier SetAccessSpecifier(AccessSpecifier accessSpecifier) noexcept = 0;
	virtual natRefPointer<Object> Invoke(ArgumentPack const& pack) = 0;
	virtual bool CompatWith(ArgumentPack const& pack) const noexcept = 0;
	virtual natRefPointer<IType> GetReturnType() const noexcept = 0;
	virtual size_t GetArgumentCount() const noexcept = 0;
	virtual natRefPointer<IType> GetArgumentType(size_t n) const noexcept = 0;
};

struct IMemberMethod
	: Interface
{
	virtual AccessSpecifier GetAccessSpecifier() const noexcept = 0;
	virtual AccessSpecifier SetAccessSpecifier(AccessSpecifier accessSpecifier) noexcept = 0;
	virtual natRefPointer<Object> Invoke(natRefPointer<Object> object, ArgumentPack const& pack) = 0;
	virtual bool CompatWith(natRefPointer<Object> object, ArgumentPack const& pack) const noexcept = 0;
	virtual natRefPointer<IType> GetReturnType() const noexcept = 0;
	virtual natRefPointer<IType> GetClassType() const noexcept = 0;
	virtual size_t GetArgumentCount() const noexcept = 0;
	virtual natRefPointer<IType> GetArgumentType(size_t n) const noexcept = 0;
	virtual bool IsConstMemberMethod() const noexcept = 0;
};

struct IField
	: Interface
{
	virtual natRefPointer<IType> GetType() = 0;
	virtual AccessSpecifier GetAccessSpecifier() const noexcept = 0;
	virtual AccessSpecifier SetAccessSpecifier(AccessSpecifier accessSpecifier) noexcept = 0;
	virtual bool IsPointer() const noexcept = 0;
	virtual natRefPointer<Object> Read() = 0;
	virtual void Write(natRefPointer<Object> value) = 0;
};

struct IMemberField
	: Interface
{
	virtual natRefPointer<IType> GetType() = 0;
	virtual AccessSpecifier GetAccessSpecifier() const noexcept = 0;
	virtual AccessSpecifier SetAccessSpecifier(AccessSpecifier accessSpecifier) noexcept = 0;
	virtual bool IsPointer() const noexcept = 0;
	virtual natRefPointer<Object> ReadFrom(natRefPointer<Object> object) = 0;
	virtual void WriteFrom(natRefPointer<Object> object, natRefPointer<Object> value) = 0;
};

////////////////////////////////////////////////////////////////////////////////
/// @brief	类型接口
////////////////////////////////////////////////////////////////////////////////
struct IType
	: Interface
{
	virtual void RegisterBaseClasses(std::initializer_list<natRefPointer<IType>> baseClasses) = 0;
	virtual void RegisterNonMemberMethod(ncTStr name, natRefPointer<IMethod> method) = 0;
	virtual void RegisterMemberMethod(ncTStr name, natRefPointer<IMemberMethod> method) = 0;
	virtual void RegisterNonMemberField(ncTStr name, natRefPointer<IField> field) = 0;
	virtual void RegisterMemberField(ncTStr name, natRefPointer<IMemberField> field) = 0;

	virtual ncTStr GetName() const noexcept = 0;
	virtual natRefPointer<Object> Construct(ArgumentPack const& args) = 0;
	virtual size_t GetBaseClassesCount() const noexcept = 0;
	virtual natRefPointer<IType> GetBaseClass(size_t n) const noexcept = 0;
	virtual Linq<const natRefPointer<IType>> GetBaseClasses() const noexcept = 0;
	virtual natRefPointer<Object> InvokeNonMember(ncTStr name, ArgumentPack const& args) = 0;
	virtual natRefPointer<Object> InvokeMember(natRefPointer<Object> object, ncTStr name, ArgumentPack const& args) = 0;
	virtual natRefPointer<IMethod> GetNonMemberMethod(ncTStr name, std::initializer_list<natRefPointer<IType>> const& argTypes) = 0;
	virtual natRefPointer<IMemberMethod> GetMemberMethod(ncTStr name, std::initializer_list<natRefPointer<IType>> const& argTypes) = 0;
	virtual bool IsNonMemberFieldPointer(ncTStr name) = 0;
	virtual bool IsMemberFieldPointer(ncTStr name) = 0;
	virtual natRefPointer<Object> ReadNonMemberField(ncTStr name) = 0;
	virtual natRefPointer<Object> ReadMemberField(natRefPointer<Object> object, ncTStr name) = 0;
	virtual void WriteNonMemberField(ncTStr name, natRefPointer<Object> value) = 0;
	virtual void WriteMemberField(natRefPointer<Object> object, ncTStr name, natRefPointer<Object> value) = 0;
	virtual natRefPointer<IField> GetNonMemberField(ncTStr name) = 0;
	virtual natRefPointer<IMemberField> GetMemberField(ncTStr name) = 0;

	/// @brief	枚举该类型下的非成员，当枚举函数返回true时立即结束枚举
	///	@param	recurse		递归地枚举父类中的非成员
	/// @param	enumFunc	枚举函数，接受参数的含义为 非成员名，是否为方法，非方法的类型（若是方法则为nullptr），返回bool值
	/// @return	是否因枚举函数返回true而结束枚举
	virtual bool EnumNonMember(bool recurse, Delegate<bool(ncTStr, bool, natRefPointer<IType>)> enumFunc) const = 0;

	/// @brief	枚举该类型下的成员，当枚举函数返回true时立即结束枚举
	///	@param	recurse		递归地枚举父类中的非成员
	/// @param	enumFunc	枚举函数，接受参数的含义为 成员名，是否为方法，非方法的类型（若是方法则为nullptr），返回bool值
	/// @return	是否因枚举函数返回true而结束枚举
	virtual bool EnumMember(bool recurse, Delegate<bool(ncTStr, bool, natRefPointer<IType>)> enumFunc) const = 0;

	virtual std::type_index GetTypeIndex() const noexcept = 0;
	virtual bool Equal(const IType* other) const noexcept = 0;

	//virtual bool IsConvertable(natRefPointer<IType> other) const noexcept = 0;
	virtual natRefPointer<Object> ConvertTo(natRefPointer<Object> object, natRefPointer<IType> toType) const = 0;

	virtual bool IsExtendFrom(natRefPointer<IType> type) const = 0;
};
